import rclpy
from rclpy.node import Node
from geometry_msgs.msg import PointStamped
from std_msgs.msg import Bool
import pyrealsense2 as rs
import numpy as np
import cv2
import google.generativeai as genai
import PIL.Image
import json
import os
import logging
import time
from collections import deque

# 로그 정리
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'
logging.getLogger('google').setLevel(logging.ERROR)

class GeminiVLANode(Node):
    def __init__(self):
        super().__init__('gemini_vla_node')
        self.towel_pub = self.create_publisher(PointStamped, 'target_towel_point', 10)
        # Legacy topic is kept for compatibility with older orchestrator versions.
        self.tissue_pub = self.create_publisher(PointStamped, 'target_tissue_point', 10)
        self.water_pub = self.create_publisher(PointStamped, 'target_water_point', 10)
        self.sequence_active_sub = self.create_subscription(
            Bool, '/wipe_sequence_active', self.sequence_active_callback, 10
        )
        
        genai.configure(api_key="AIzaSyDWlAnpKZGodTvl-AHf9Si9e0dVav8QTnQ")
        self.model = genai.GenerativeModel('gemini-2.5-flash')

        self.pipeline = rs.pipeline()
        config = rs.config()
        config.enable_stream(rs.stream.color, 640, 480, rs.format.bgr8, 30)
        self.pipeline.start(config)
        
        self.roi_x1, self.roi_y1, self.roi_x2, self.roi_y2 = 150, 120, 490, 400
        # Image tone defaults (no extra glare compensation).
        self.brightness_alpha = 1.0
        self.brightness_beta = 0
        self.max_history = 10
        self.towel_history = deque(maxlen=self.max_history)
        self.water_history = deque(maxlen=self.max_history)
        self.last_towel_avg = None
        self.last_water_avg = None
        self.reset_thresh_towel_px = 120.0
        self.reset_thresh_water_px = 80.0
        self.sequence_active = False
        self.prev_sequence_active = False
        self.towel_locked = False
        self.water_locked = False
        self.lock_republish_period_sec = 1.0
        self.last_towel_republish_mono = 0.0
        self.last_water_republish_mono = 0.0

        self.get_logger().info('=== Gemini Node: Ready for Towel+Water Detection ===')
        cv2.namedWindow("VLA View")
        cv2.setMouseCallback("VLA View", self.on_mouse)
        self.timer = self.create_timer(1.0, self.timer_callback)

    def on_mouse(self, event, x, y, flags, param):
        if event == cv2.EVENT_LBUTTONDOWN:
            self.get_logger().info(f"픽셀 클릭 좌표: ({x}, {y})")

    def sequence_active_callback(self, msg):
        self.sequence_active = bool(msg.data)
        if self.sequence_active and not self.prev_sequence_active:
            self.get_logger().info("시퀀스 시작 신호 수신: 좌표 전송 잠금 유지")
        if not self.sequence_active and self.prev_sequence_active:
            # Full sequence finished -> unlock for next cycle.
            self.get_logger().info("시퀀스 종료 신호 수신: 다음 사이클 좌표 재탐색 허용")
            self.towel_locked = False
            self.water_locked = False
            self.towel_history.clear()
            self.water_history.clear()
        self.prev_sequence_active = self.sequence_active

    def timer_callback(self):
        try:
            frames = self.pipeline.wait_for_frames()
            color_frame = frames.get_color_frame()
            if not color_frame: return

            img_np = np.asanyarray(color_frame.get_data())
            img_np = cv2.convertScaleAbs(
                img_np, alpha=self.brightness_alpha, beta=self.brightness_beta
            )
            roi_img = img_np[self.roi_y1:self.roi_y2, self.roi_x1:self.roi_x2].copy()
            
            rgb_img = cv2.cvtColor(roi_img, cv2.COLOR_BGR2RGB)
            pil_img = PIL.Image.fromarray(rgb_img)
            
            towel_xy, water_xy = None, None
            if not self.sequence_active:
                towel_xy, water_xy = self._infer_targets(pil_img)

                if towel_xy and not self.towel_locked:
                    self._update_history_and_publish(
                        towel_xy,
                        self.towel_history,
                        "towel",
                        self.towel_pub,
                    )
                if water_xy and not self.water_locked:
                    self._update_history_and_publish(
                        water_xy,
                        self.water_history,
                        "water",
                        self.water_pub,
                    )
                self._republish_locked_targets_if_needed()
            else:
                self.get_logger().info("시퀀스 진행 중: 좌표 탐색 일시정지")

            # UI: ROI와 타겟 표시
            cv2.rectangle(
                img_np,
                (self.roi_x1, self.roi_y1),
                (self.roi_x2, self.roi_y2),
                (255, 255, 0),
                1,
            )
            if towel_xy:
                cv2.circle(img_np, (int(towel_xy[0]), int(towel_xy[1])), 5, (0, 0, 255), -1)
            if water_xy:
                cv2.circle(img_np, (int(water_xy[0]), int(water_xy[1])), 5, (255, 0, 0), -1)
            if len(self.towel_history) >= 2:
                towel_pts = np.array(
                    [[int(x), int(y)] for x, y in self.towel_history], dtype=np.int32
                ).reshape((-1, 1, 2))
                cv2.polylines(img_np, [towel_pts], False, (0, 128, 255), 2)
            if len(self.water_history) >= 2:
                water_pts = np.array(
                    [[int(x), int(y)] for x, y in self.water_history], dtype=np.int32
                ).reshape((-1, 1, 2))
                cv2.polylines(img_np, [water_pts], False, (255, 255, 0), 2)
            if self.last_towel_avg:
                cv2.circle(
                    img_np,
                    (int(self.last_towel_avg[0]), int(self.last_towel_avg[1])),
                    6,
                    (0, 255, 0),
                    -1,
                )
            if self.last_water_avg:
                cv2.circle(
                    img_np,
                    (int(self.last_water_avg[0]), int(self.last_water_avg[1])),
                    6,
                    (0, 255, 255),
                    -1,
                )
            cv2.imshow("VLA View", img_np)
            cv2.waitKey(1)

        except Exception as e:
            self.get_logger().error(f"Error: {e}")

    def _infer_targets(self, pil_img):
        prompt = (
            "Return JSON only: "
            "{\"towel\": {\"x\": 0-1000, \"y\": 0-1000} or null, "
            "\"water\": {\"x\": 0-1000, \"y\": 0-1000} or null} "
            "for the center of the folded towel and the spilled water."
        )
        response = self.model.generate_content([prompt, pil_img])
        res_text = response.text
        start, end = res_text.find('{'), res_text.rfind('}') + 1
        if start == -1:
            return None, None
        data = json.loads(res_text[start:end])
        roi_w, roi_h = self.roi_x2 - self.roi_x1, self.roi_y2 - self.roi_y1

        def _map_xy(obj):
            if not obj or obj.get('x') is None or obj.get('y') is None:
                return None
            raw_x = (float(obj['x']) / 1000.0) * roi_w + self.roi_x1
            raw_y = (float(obj['y']) / 1000.0) * roi_h + self.roi_y1
            return raw_x, raw_y

        towel_xy = _map_xy(data.get("towel")) or _map_xy(data.get("tissue"))
        water_xy = _map_xy(data.get("water"))
        return towel_xy, water_xy

    def _update_history_and_publish(self, xy, history, label, publisher):
        raw_x, raw_y = xy

        if history:
            median_x_tmp = float(np.median([c[0] for c in history]))
            median_y_tmp = float(np.median([c[1] for c in history]))
            reset_thresh = (
                self.reset_thresh_towel_px if label == "towel" else self.reset_thresh_water_px
            )
            if np.sqrt((raw_x - median_x_tmp) ** 2 + (raw_y - median_y_tmp) ** 2) > reset_thresh:
                history.clear()

        history.append((raw_x, raw_y))

        if len(history) >= self.max_history:
            avg_x = float(np.median([c[0] for c in history]))
            avg_y = float(np.median([c[1] for c in history]))
            if label == "towel":
                self.last_towel_avg = (avg_x, avg_y)
                self.towel_locked = True
                # Publish to both new and legacy topics.
                legacy_msg = PointStamped()
                legacy_msg.header.stamp = self.get_clock().now().to_msg()
                legacy_msg.point.x, legacy_msg.point.y = float(avg_x), float(avg_y)
                self.tissue_pub.publish(legacy_msg)
            else:
                self.last_water_avg = (avg_x, avg_y)
                self.water_locked = True

            msg = PointStamped()
            msg.header.stamp = self.get_clock().now().to_msg()
            msg.point.x, msg.point.y = float(avg_x), float(avg_y)
            publisher.publish(msg)
            self.get_logger().info(
                f'>> {label} Target Sent: ({int(avg_x)}, {int(avg_y)}) [lock=True]'
            )
            history.clear()
        else:
            self.get_logger().info(f"{label} Sampling... {len(history)}/{self.max_history}")

    def _republish_locked_targets_if_needed(self):
        now_mono = time.monotonic()
        if self.towel_locked and self.last_towel_avg is not None:
            if now_mono - self.last_towel_republish_mono >= self.lock_republish_period_sec:
                msg = PointStamped()
                msg.header.stamp = self.get_clock().now().to_msg()
                msg.point.x, msg.point.y = float(self.last_towel_avg[0]), float(self.last_towel_avg[1])
                self.towel_pub.publish(msg)
                legacy_msg = PointStamped()
                legacy_msg.header.stamp = self.get_clock().now().to_msg()
                legacy_msg.point.x, legacy_msg.point.y = float(self.last_towel_avg[0]), float(self.last_towel_avg[1])
                self.tissue_pub.publish(legacy_msg)
                self.last_towel_republish_mono = now_mono
                self.get_logger().info(
                    f">> towel Target ReSent: ({int(self.last_towel_avg[0])}, {int(self.last_towel_avg[1])})"
                )

        if self.water_locked and self.last_water_avg is not None:
            if now_mono - self.last_water_republish_mono >= self.lock_republish_period_sec:
                msg = PointStamped()
                msg.header.stamp = self.get_clock().now().to_msg()
                msg.point.x, msg.point.y = float(self.last_water_avg[0]), float(self.last_water_avg[1])
                self.water_pub.publish(msg)
                self.last_water_republish_mono = now_mono
                self.get_logger().info(
                    f">> water Target ReSent: ({int(self.last_water_avg[0])}, {int(self.last_water_avg[1])})"
                )

    def _suppress_specular_glare(self, bgr_img):
        hsv = cv2.cvtColor(bgr_img, cv2.COLOR_BGR2HSV)
        h, s, v = cv2.split(hsv)
        # Typical reflection: low saturation + very high value.
        glare_mask = (s < self.specular_s_max) & (v > self.specular_v_min)
        v = np.where(glare_mask, self.specular_v_target, v).astype(np.uint8)
        hsv_fixed = cv2.merge([h, s, v])
        return cv2.cvtColor(hsv_fixed, cv2.COLOR_HSV2BGR)

    def _draw_ring_marker(self, img, xy, color, text):
        x, y = int(xy[0]), int(xy[1])
        cv2.circle(img, (x, y), 7, color, 2)
        cv2.circle(img, (x, y), 2, color, -1)
        cv2.line(img, (x - 10, y), (x - 4, y), color, 1)
        cv2.line(img, (x + 4, y), (x + 10, y), color, 1)
        cv2.line(img, (x, y - 10), (x, y - 4), color, 1)
        cv2.line(img, (x, y + 4), (x, y + 10), color, 1)
        cv2.putText(img, text, (x + 10, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.4, color, 1, cv2.LINE_AA)

    def _draw_fade_trail(self, img, history, color):
        points = [(int(x), int(y)) for x, y in history]
        for i in range(1, len(points)):
            alpha = i / float(len(points))
            thickness = max(1, int(1 + 2 * alpha))
            seg_color = (
                int(color[0] * alpha),
                int(color[1] * alpha),
                int(color[2] * alpha),
            )
            cv2.line(img, points[i - 1], points[i], seg_color, thickness, cv2.LINE_AA)

    def _draw_direction_arrows(self, img, history, color):
        points = [(int(x), int(y)) for x, y in history]
        if len(points) < 3:
            return
        step = max(2, len(points) // 3)
        for i in range(step, len(points), step):
            p1 = points[i - 1]
            p2 = points[i]
            cv2.arrowedLine(img, p1, p2, color, 1, cv2.LINE_AA, tipLength=0.4)

    def _draw_status_hud(self, img):
        hud_x, hud_y = 10, 10
        hud_w, hud_h = 240, 78
        cv2.rectangle(img, (hud_x, hud_y), (hud_x + hud_w, hud_y + hud_h), (24, 24, 24), -1)
        cv2.rectangle(img, (hud_x, hud_y), (hud_x + hud_w, hud_y + hud_h), (90, 90, 90), 1)
        seq_text = "ACTIVE" if self.sequence_active else "IDLE"
        cv2.putText(
            img,
            f"SEQ: {seq_text}",
            (hud_x + 10, hud_y + 20),
            cv2.FONT_HERSHEY_SIMPLEX,
            0.5,
            (180, 255, 180) if self.sequence_active else (220, 220, 220),
            1,
            cv2.LINE_AA,
        )
        cv2.putText(
            img,
            f"Towel lock: {self.towel_locked} ({len(self.towel_history)}/{self.max_history})",
            (hud_x + 10, hud_y + 40),
            cv2.FONT_HERSHEY_SIMPLEX,
            0.45,
            (0, 220, 255),
            1,
            cv2.LINE_AA,
        )
        cv2.putText(
            img,
            f"Water lock: {self.water_locked} ({len(self.water_history)}/{self.max_history})",
            (hud_x + 10, hud_y + 60),
            cv2.FONT_HERSHEY_SIMPLEX,
            0.45,
            (255, 220, 0),
            1,
            cv2.LINE_AA,
        )

def main(args=None):
    rclpy.init(args=args)
    node = GeminiVLANode()
    try: rclpy.spin(node)
    except KeyboardInterrupt: pass
    finally:
        node.pipeline.stop()
        node.destroy_node()
        rclpy.shutdown()
