import rclpy
from rclpy.node import Node
from geometry_msgs.msg import PointStamped
from std_msgs.msg import Bool
import pyrealsense2 as rs
import numpy as np
import cv2
import google.generativeai as genai
import PIL.Image
import json
import os
import logging
import time
from collections import deque

# 로그 정리
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'
logging.getLogger('google').setLevel(logging.ERROR)

class GeminiVLANode(Node):
    def __init__(self):
        super().__init__('gemini_vla_node')
        self.towel_pub = self.create_publisher(PointStamped, 'target_towel_point', 10)
        # Legacy topic is kept for compatibility with older orchestrator versions.
        self.tissue_pub = self.create_publisher(PointStamped, 'target_tissue_point', 10)
        self.water_pub = self.create_publisher(PointStamped, 'target_water_point', 10)
        self.sequence_active_sub = self.create_subscription(
            Bool, '/wipe_sequence_active', self.sequence_active_callback, 10
        )
        
        genai.configure(api_key="AIzaSyDWlAnpKZGodTvl-AHf9Si9e0dVav8QTnQ")
        self.model = genai.GenerativeModel('gemini-2.5-flash')

        self.pipeline = rs.pipeline()
        config = rs.config()
        config.enable_stream(rs.stream.color, 640, 480, rs.format.bgr8, 30)
        self.pipeline.start(config)
        
        self.roi_x1, self.roi_y1, self.roi_x2, self.roi_y2 = 150, 120, 490, 400
        # Image tone defaults (no extra glare compensation).
        self.brightness_alpha = 0.92
        self.brightness_beta = -8
        self.max_history = 10
        self.towel_required_samples = 8
        self.water_required_samples = 5
        self.towel_history = deque(maxlen=self.max_history)
        self.water_history = deque(maxlen=self.max_history)
        self.last_towel_avg = None
        self.last_water_avg = None
        self.reset_thresh_towel_px = 120.0
        self.reset_thresh_water_px = 80.0
        self.sequence_active = False
        self.prev_sequence_active = False
        self.towel_locked = False
        self.water_locked = False
        self.lock_republish_period_sec = 1.0
        self.last_towel_republish_mono = 0.0
        self.last_water_republish_mono = 0.0
        # Water detection stabilization for glare-heavy scenes.
        self.water_hold_sec = 12.0
        self.last_water_valid_xy = None
        self.last_water_valid_mono = 0.0
        self.water_gate_x_min_ratio = 0.20
        self.water_gate_x_max_ratio = 1.00
        self.water_gate_y_min_ratio = 0.05
        self.water_gate_y_max_ratio = 0.98
        # Camera auto-exposure settles in the first seconds.
        self.startup_stabilize_sec = 3.0
        self.start_mono = time.monotonic()

        self.get_logger().info('=== Gemini Node: Ready for Towel+Water Detection ===')
        cv2.namedWindow("VLA View")
        cv2.setMouseCallback("VLA View", self.on_mouse)
        self.timer = self.create_timer(0.25, self.timer_callback)

    def on_mouse(self, event, x, y, flags, param):
        if event == cv2.EVENT_LBUTTONDOWN:
            self.get_logger().info(f"픽셀 클릭 좌표: ({x}, {y})")

    def sequence_active_callback(self, msg):
        self.sequence_active = bool(msg.data)
        if self.sequence_active and not self.prev_sequence_active:
            self.get_logger().info("시퀀스 시작 신호 수신: 좌표 전송 잠금 유지")
        if not self.sequence_active and self.prev_sequence_active:
            # Full sequence finished -> unlock for next cycle.
            self.get_logger().info("시퀀스 종료 신호 수신: 다음 사이클 좌표 재탐색 허용")
            self.towel_locked = False
            self.water_locked = False
            self.towel_history.clear()
            self.water_history.clear()
        self.prev_sequence_active = self.sequence_active

    def timer_callback(self):
        try:
            frames = self.pipeline.wait_for_frames()
            color_frame = frames.get_color_frame()
            if not color_frame: return

            img_np = np.asanyarray(color_frame.get_data())
            img_np = cv2.convertScaleAbs(
                img_np, alpha=self.brightness_alpha, beta=self.brightness_beta
            )
            roi_img = img_np[self.roi_y1:self.roi_y2, self.roi_x1:self.roi_x2].copy()
            
            rgb_img = cv2.cvtColor(roi_img, cv2.COLOR_BGR2RGB)
            pil_img = PIL.Image.fromarray(rgb_img)

            if (time.monotonic() - self.start_mono) < self.startup_stabilize_sec:
                cv2.rectangle(
                    img_np,
                    (self.roi_x1, self.roi_y1),
                    (self.roi_x2, self.roi_y2),
                    (255, 255, 0),
                    1,
                )
                cv2.putText(
                    img_np,
                    "Camera stabilizing...",
                    (self.roi_x1 + 8, self.roi_y1 + 20),
                    cv2.FONT_HERSHEY_SIMPLEX,
                    0.5,
                    (0, 255, 255),
                    1,
                    cv2.LINE_AA,
                )
                cv2.imshow("VLA View", img_np)
                cv2.waitKey(1)
                return
            
            towel_xy, water_xy = None, None
            if not self.sequence_active:
                if not self.towel_locked:
                    towel_xy, water_xy = self._infer_targets(pil_img)
                    if towel_xy:
                        self._update_history_and_publish(
                            towel_xy,
                            self.towel_history,
                            "towel",
                            self.towel_pub,
                        )
                else:
                    water_xy = self._infer_water_only(pil_img)
                    if water_xy is None:
                        _, water_xy = self._infer_targets(pil_img)
                    if water_xy is None:
                        water_xy = self._infer_water_fallback_cv(roi_img)

                water_xy = self._normalize_water_candidate(water_xy)

                if water_xy and not self.water_locked:
                    self._update_history_and_publish(
                        water_xy,
                        self.water_history,
                        "water",
                        self.water_pub,
                    )
                self._republish_locked_targets_if_needed()
            else:
                self.get_logger().info("시퀀스 진행 중: 좌표 탐색 일시정지")

            # UI: ROI와 타겟 표시
            cv2.rectangle(
                img_np,
                (self.roi_x1, self.roi_y1),
                (self.roi_x2, self.roi_y2),
                (255, 255, 0),
                1,
            )
            if towel_xy:
                cv2.circle(img_np, (int(towel_xy[0]), int(towel_xy[1])), 5, (0, 0, 255), -1)
            if water_xy:
                cv2.circle(img_np, (int(water_xy[0]), int(water_xy[1])), 5, (255, 0, 0), -1)
            if len(self.towel_history) >= 2:
                towel_pts = np.array(
                    [[int(x), int(y)] for x, y in self.towel_history], dtype=np.int32
                ).reshape((-1, 1, 2))
                cv2.polylines(img_np, [towel_pts], False, (0, 128, 255), 2)
            if len(self.water_history) >= 2:
                water_pts = np.array(
                    [[int(x), int(y)] for x, y in self.water_history], dtype=np.int32
                ).reshape((-1, 1, 2))
                cv2.polylines(img_np, [water_pts], False, (255, 255, 0), 2)
            if self.last_towel_avg:
                cv2.circle(
                    img_np,
                    (int(self.last_towel_avg[0]), int(self.last_towel_avg[1])),
                    6,
                    (0, 255, 0),
                    -1,
                )
            if self.last_water_avg:
                cv2.circle(
                    img_np,
                    (int(self.last_water_avg[0]), int(self.last_water_avg[1])),
                    6,
                    (0, 255, 255),
                    -1,
                )
            cv2.imshow("VLA View", img_np)
            cv2.waitKey(1)

        except Exception as e:
            self.get_logger().error(f"Error: {e}")

    def _infer_targets(self, pil_img):
        prompt = (
            "Return JSON only: "
            "{\"towel\": {\"x\": 0-1000, \"y\": 0-1000} or null, "
            "\"water\": {\"x\": 0-1000, \"y\": 0-1000} or null} "
            "for the center of the folded towel and the spilled water puddle/wet stain. "
            "Ignore glossy white reflections, glare, or bright specular highlights."
        )
        response = self.model.generate_content([prompt, pil_img])
        data = self._extract_json_dict(response.text)
        if data is None:
            return None, None
        roi_w, roi_h = self.roi_x2 - self.roi_x1, self.roi_y2 - self.roi_y1

        def _map_xy(obj):
            if not obj or obj.get('x') is None or obj.get('y') is None:
                return None
            raw_x = (float(obj['x']) / 1000.0) * roi_w + self.roi_x1
            raw_y = (float(obj['y']) / 1000.0) * roi_h + self.roi_y1
            return raw_x, raw_y

        towel_xy = _map_xy(data.get("towel")) or _map_xy(data.get("tissue"))
        water_xy = _map_xy(data.get("water"))
        return towel_xy, water_xy

    def _infer_water_only(self, pil_img):
        prompt = (
            "Return JSON only: "
            "{\"water\": {\"x\": 0-1000, \"y\": 0-1000} or null} "
            "for the center of spilled water puddle/wet stain on the table. "
            "Ignore glossy white reflections, glare, and robot body."
        )
        water_xy = self._run_water_prompt(pil_img, prompt)
        if water_xy is not None:
            return water_xy

        fallback_prompt = (
            "Return JSON only: "
            "{\"water\": {\"x\": 0-1000, \"y\": 0-1000} or null} "
            "Find the most likely wet region on the table surface, even if faint. "
            "Do not return bright specular reflections or robot parts."
        )
        return self._run_water_prompt(pil_img, fallback_prompt)

    def _infer_water_fallback_cv(self, roi_img_bgr):
        # CV fallback: detect likely wet patch by local darkness/texture change on bright table.
        gray = cv2.cvtColor(roi_img_bgr, cv2.COLOR_BGR2GRAY)
        blur = cv2.GaussianBlur(gray, (9, 9), 0)
        diff = cv2.subtract(blur, gray)
        _, mask = cv2.threshold(diff, 10, 255, cv2.THRESH_BINARY)

        # Remove tiny noise and connect nearby pixels.
        kernel = np.ones((5, 5), np.uint8)
        mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel, iterations=1)
        mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel, iterations=2)

        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        if not contours:
            return None

        roi_h, roi_w = gray.shape[:2]
        min_area = max(80, int(0.0015 * roi_w * roi_h))
        max_area = int(0.25 * roi_w * roi_h)
        candidates = [c for c in contours if min_area <= cv2.contourArea(c) <= max_area]
        if not candidates:
            return None

        # Prefer candidates near the recent valid water coordinate if available.
        best = None
        best_score = -1e9
        for c in candidates:
            area = cv2.contourArea(c)
            m = cv2.moments(c)
            if m["m00"] == 0:
                continue
            cx = float(m["m10"] / m["m00"]) + self.roi_x1
            cy = float(m["m01"] / m["m00"]) + self.roi_y1
            score = area
            if self.last_water_valid_xy is not None:
                dx = cx - self.last_water_valid_xy[0]
                dy = cy - self.last_water_valid_xy[1]
                score -= 0.6 * np.hypot(dx, dy)
            if score > best_score:
                best_score = score
                best = (cx, cy)
        return best

    def _run_water_prompt(self, pil_img, prompt):
        response = self.model.generate_content([prompt, pil_img])
        data = self._extract_json_dict(response.text)
        if data is None:
            return None
        obj = data.get("water")
        if not obj or obj.get("x") is None or obj.get("y") is None:
            return None
        roi_w, roi_h = self.roi_x2 - self.roi_x1, self.roi_y2 - self.roi_y1
        raw_x = (float(obj["x"]) / 1000.0) * roi_w + self.roi_x1
        raw_y = (float(obj["y"]) / 1000.0) * roi_h + self.roi_y1
        return raw_x, raw_y

    def _extract_json_dict(self, text):
        if not text:
            return None
        start, end = text.find("{"), text.rfind("}") + 1
        if start == -1 or end <= start:
            return None
        try:
            obj = json.loads(text[start:end])
            return obj if isinstance(obj, dict) else None
        except Exception:
            return None

    def _update_history_and_publish(self, xy, history, label, publisher):
        raw_x, raw_y = xy

        if history:
            median_x_tmp = float(np.median([c[0] for c in history]))
            median_y_tmp = float(np.median([c[1] for c in history]))
            reset_thresh = (
                self.reset_thresh_towel_px if label == "towel" else self.reset_thresh_water_px
            )
            if np.sqrt((raw_x - median_x_tmp) ** 2 + (raw_y - median_y_tmp) ** 2) > reset_thresh:
                history.clear()

        history.append((raw_x, raw_y))

        required_samples = (
            self.towel_required_samples if label == "towel" else self.water_required_samples
        )
        if len(history) >= required_samples:
            avg_x = float(np.median([c[0] for c in history]))
            avg_y = float(np.median([c[1] for c in history]))
            if label == "towel":
                self.last_towel_avg = (avg_x, avg_y)
                self.towel_locked = True
                # Publish to both new and legacy topics.
                legacy_msg = PointStamped()
                legacy_msg.header.stamp = self.get_clock().now().to_msg()
                legacy_msg.point.x, legacy_msg.point.y = float(avg_x), float(avg_y)
                self.tissue_pub.publish(legacy_msg)
            else:
                self.last_water_avg = (avg_x, avg_y)
                self.water_locked = True

            msg = PointStamped()
            msg.header.stamp = self.get_clock().now().to_msg()
            msg.point.x, msg.point.y = float(avg_x), float(avg_y)
            publisher.publish(msg)
            self.get_logger().info(
                f'>> {label} Target Sent: ({int(avg_x)}, {int(avg_y)}) [lock=True]'
            )
            history.clear()
        else:
            self.get_logger().info(f"{label} Sampling... {len(history)}/{required_samples}")

    def _republish_locked_targets_if_needed(self):
        now_mono = time.monotonic()
        # Towel re-send is disabled after first lock to avoid re-search noise.
        # It will be unlocked only when a full robot sequence is completed.

        if self.water_locked and self.last_water_avg is not None:
            if now_mono - self.last_water_republish_mono >= self.lock_republish_period_sec:
                msg = PointStamped()
                msg.header.stamp = self.get_clock().now().to_msg()
                msg.point.x, msg.point.y = float(self.last_water_avg[0]), float(self.last_water_avg[1])
                self.water_pub.publish(msg)
                self.last_water_republish_mono = now_mono
                self.get_logger().info(
                    f">> water Target ReSent: ({int(self.last_water_avg[0])}, {int(self.last_water_avg[1])})"
                )

    def _normalize_water_candidate(self, water_xy):
        now_mono = time.monotonic()
        if water_xy is not None and self._is_in_water_gate(water_xy):
            self.last_water_valid_xy = (float(water_xy[0]), float(water_xy[1]))
            self.last_water_valid_mono = now_mono
            return water_xy

        if self.last_water_valid_xy is not None:
            if (now_mono - self.last_water_valid_mono) <= self.water_hold_sec:
                self.get_logger().info("water hold: using last valid water coordinate")
                return self.last_water_valid_xy
        return None

    def _is_in_water_gate(self, xy):
        x, y = float(xy[0]), float(xy[1])
        roi_w = float(self.roi_x2 - self.roi_x1)
        roi_h = float(self.roi_y2 - self.roi_y1)
        x_min = self.roi_x1 + self.water_gate_x_min_ratio * roi_w
        x_max = self.roi_x1 + self.water_gate_x_max_ratio * roi_w
        y_min = self.roi_y1 + self.water_gate_y_min_ratio * roi_h
        y_max = self.roi_y1 + self.water_gate_y_max_ratio * roi_h
        return x_min <= x <= x_max and y_min <= y <= y_max

    def _suppress_specular_glare(self, bgr_img):
        hsv = cv2.cvtColor(bgr_img, cv2.COLOR_BGR2HSV)
        h, s, v = cv2.split(hsv)
        # Typical reflection: low saturation + very high value.
        glare_mask = (s < self.specular_s_max) & (v > self.specular_v_min)
        v = np.where(glare_mask, self.specular_v_target, v).astype(np.uint8)
        hsv_fixed = cv2.merge([h, s, v])
        return cv2.cvtColor(hsv_fixed, cv2.COLOR_HSV2BGR)

    def _draw_ring_marker(self, img, xy, color, text):
        x, y = int(xy[0]), int(xy[1])
        cv2.circle(img, (x, y), 7, color, 2)
        cv2.circle(img, (x, y), 2, color, -1)
        cv2.line(img, (x - 10, y), (x - 4, y), color, 1)
        cv2.line(img, (x + 4, y), (x + 10, y), color, 1)
        cv2.line(img, (x, y - 10), (x, y - 4), color, 1)
        cv2.line(img, (x, y + 4), (x, y + 10), color, 1)
        cv2.putText(img, text, (x + 10, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.4, color, 1, cv2.LINE_AA)

    def _draw_fade_trail(self, img, history, color):
        points = [(int(x), int(y)) for x, y in history]
        for i in range(1, len(points)):
            alpha = i / float(len(points))
            thickness = max(1, int(1 + 2 * alpha))
            seg_color = (
                int(color[0] * alpha),
                int(color[1] * alpha),
                int(color[2] * alpha),
            )
            cv2.line(img, points[i - 1], points[i], seg_color, thickness, cv2.LINE_AA)

    def _draw_direction_arrows(self, img, history, color):
        points = [(int(x), int(y)) for x, y in history]
        if len(points) < 3:
            return
        step = max(2, len(points) // 3)
        for i in range(step, len(points), step):
            p1 = points[i - 1]
            p2 = points[i]
            cv2.arrowedLine(img, p1, p2, color, 1, cv2.LINE_AA, tipLength=0.4)

    def _draw_status_hud(self, img):
        hud_x, hud_y = 10, 10
        hud_w, hud_h = 240, 78
        cv2.rectangle(img, (hud_x, hud_y), (hud_x + hud_w, hud_y + hud_h), (24, 24, 24), -1)
        cv2.rectangle(img, (hud_x, hud_y), (hud_x + hud_w, hud_y + hud_h), (90, 90, 90), 1)
        seq_text = "ACTIVE" if self.sequence_active else "IDLE"
        cv2.putText(
            img,
            f"SEQ: {seq_text}",
            (hud_x + 10, hud_y + 20),
            cv2.FONT_HERSHEY_SIMPLEX,
            0.5,
            (180, 255, 180) if self.sequence_active else (220, 220, 220),
            1,
            cv2.LINE_AA,
        )
        cv2.putText(
            img,
            f"Towel lock: {self.towel_locked} ({len(self.towel_history)}/{self.max_history})",
            (hud_x + 10, hud_y + 40),
            cv2.FONT_HERSHEY_SIMPLEX,
            0.45,
            (0, 220, 255),
            1,
            cv2.LINE_AA,
        )
        cv2.putText(
            img,
            f"Water lock: {self.water_locked} ({len(self.water_history)}/{self.max_history})",
            (hud_x + 10, hud_y + 60),
            cv2.FONT_HERSHEY_SIMPLEX,
            0.45,
            (255, 220, 0),
            1,
            cv2.LINE_AA,
        )

def main(args=None):
    rclpy.init(args=args)
    node = GeminiVLANode()
    try: rclpy.spin(node)
    except KeyboardInterrupt: pass
    finally:
        node.pipeline.stop()
        node.destroy_node()
        rclpy.shutdown()
