import rclpy
from rclpy.node import Node
from geometry_msgs.msg import PointStamped
import pyrealsense2 as rs
import numpy as np
import cv2
import google.generativeai as genai
import PIL.Image
import json
import os
import logging
from collections import deque

# 로그 정리
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'
logging.getLogger('google').setLevel(logging.ERROR)

class GeminiVLANode(Node):
    def __init__(self):
        super().__init__('gemini_vla_node')
        self.tissue_pub = self.create_publisher(PointStamped, 'target_tissue_point', 10)
        self.water_pub = self.create_publisher(PointStamped, 'target_water_point', 10)
        
        genai.configure(api_key="AIzaSyDWlAnpKZGodTvl-AHf9Si9e0dVav8QTnQ")
        self.model = genai.GenerativeModel('gemini-2.5-flash')

        self.pipeline = rs.pipeline()
        config = rs.config()
        config.enable_stream(rs.stream.color, 640, 480, rs.format.bgr8, 30)
        self.pipeline.start(config)
        
        self.roi_x1, self.roi_y1, self.roi_x2, self.roi_y2 = 150, 120, 490, 400
        self.max_history = 10
        self.tissue_history = deque(maxlen=self.max_history)
        self.water_history = deque(maxlen=self.max_history)
        self.last_tissue_avg = None
        self.last_water_avg = None
        self.reset_thresh_px = 50.0

        self.get_logger().info('=== Gemini Node: Ready to Pick & Place ===')
        cv2.namedWindow("VLA View")
        cv2.setMouseCallback("VLA View", self.on_mouse)
        self.timer = self.create_timer(1.0, self.timer_callback)

    def on_mouse(self, event, x, y, flags, param):
        if event == cv2.EVENT_LBUTTONDOWN:
            self.get_logger().info(f"픽셀 클릭 좌표: ({x}, {y})")

    def timer_callback(self):
        try:
            frames = self.pipeline.wait_for_frames()
            color_frame = frames.get_color_frame()
            if not color_frame: return

            img_np = np.asanyarray(color_frame.get_data())
            roi_img = img_np[self.roi_y1:self.roi_y2, self.roi_x1:self.roi_x2].copy()
            
            rgb_img = cv2.cvtColor(roi_img, cv2.COLOR_BGR2RGB)
            pil_img = PIL.Image.fromarray(rgb_img)
            
            tissue_xy, water_xy = self._infer_targets(pil_img)

            if tissue_xy:
                self._update_history_and_publish(
                    tissue_xy,
                    self.tissue_history,
                    "tissue",
                    self.tissue_pub,
                )
            if water_xy:
                self._update_history_and_publish(
                    water_xy,
                    self.water_history,
                    "water",
                    self.water_pub,
                )

            # UI: ROI와 타겟 표시
            cv2.rectangle(
                img_np,
                (self.roi_x1, self.roi_y1),
                (self.roi_x2, self.roi_y2),
                (255, 255, 0),
                1,
            )
            if tissue_xy:
                cv2.circle(img_np, (int(tissue_xy[0]), int(tissue_xy[1])), 5, (0, 0, 255), -1)
            if self.last_tissue_avg:
                cv2.circle(
                    img_np,
                    (int(self.last_tissue_avg[0]), int(self.last_tissue_avg[1])),
                    6,
                    (0, 255, 0),
                    -1,
                )
            if water_xy:
                cv2.circle(img_np, (int(water_xy[0]), int(water_xy[1])), 5, (255, 0, 0), -1)
            if self.last_water_avg:
                cv2.circle(
                    img_np,
                    (int(self.last_water_avg[0]), int(self.last_water_avg[1])),
                    6,
                    (0, 255, 255),
                    -1,
                )
            cv2.imshow("VLA View", img_np)
            cv2.waitKey(1)

        except Exception as e:
            self.get_logger().error(f"Error: {e}")

    def _infer_targets(self, pil_img):
        prompt = (
            "Return JSON only: "
            "{\"tissue\": {\"x\": 0-1000, \"y\": 0-1000} or null, "
            "\"water\": {\"x\": 0-1000, \"y\": 0-1000} or null} "
            "for the center of the white tissue and the spilled water."
        )
        response = self.model.generate_content([prompt, pil_img])
        res_text = response.text
        start, end = res_text.find('{'), res_text.rfind('}') + 1
        if start == -1:
            return None, None
        data = json.loads(res_text[start:end])
        roi_w, roi_h = self.roi_x2 - self.roi_x1, self.roi_y2 - self.roi_y1

        def _map_xy(obj):
            if not obj or obj.get('x') is None or obj.get('y') is None:
                return None
            raw_x = (float(obj['x']) / 1000.0) * roi_w + self.roi_x1
            raw_y = (float(obj['y']) / 1000.0) * roi_h + self.roi_y1
            return raw_x, raw_y

        tissue_xy = _map_xy(data.get("tissue"))
        water_xy = _map_xy(data.get("water"))
        return tissue_xy, water_xy

    def _update_history_and_publish(self, xy, history, label, publisher):
        raw_x, raw_y = xy

        if history:
            median_x_tmp = float(np.median([c[0] for c in history]))
            median_y_tmp = float(np.median([c[1] for c in history]))
            if np.sqrt((raw_x - median_x_tmp) ** 2 + (raw_y - median_y_tmp) ** 2) > self.reset_thresh_px:
                history.clear()

        history.append((raw_x, raw_y))

        if len(history) >= self.max_history:
            avg_x = float(np.median([c[0] for c in history]))
            avg_y = float(np.median([c[1] for c in history]))
            if label == "tissue":
                self.last_tissue_avg = (avg_x, avg_y)
            else:
                self.last_water_avg = (avg_x, avg_y)

            msg = PointStamped()
            msg.header.stamp = self.get_clock().now().to_msg()
            msg.point.x, msg.point.y = float(avg_x), float(avg_y)
            publisher.publish(msg)
            self.get_logger().info(f'>> {label} Target Sent: ({int(avg_x)}, {int(avg_y)})')
            history.clear()
        else:
            self.get_logger().info(f"{label} Sampling... {len(history)}/{self.max_history}")

def main(args=None):
    rclpy.init(args=args)
    node = GeminiVLANode()
    try: rclpy.spin(node)
    except KeyboardInterrupt: pass
    finally:
        node.pipeline.stop()
        node.destroy_node()
        rclpy.shutdown()
